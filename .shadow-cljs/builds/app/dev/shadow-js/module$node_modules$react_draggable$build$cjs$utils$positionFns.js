["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-draggable/build/cjs/utils/positionFns.js"],"~:js","shadow$provide.module$node_modules$react_draggable$build$cjs$utils$positionFns=function(global,process,require,module,exports,shadow$shims){function findDOMNode(draggable){draggable=draggable.findDOMNode();if(!draggable)throw Error(\"\\x3cDraggableCore\\x3e: Unmounted during event!\");return draggable}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.getBoundPosition=function(draggable,x,y){if(!draggable.props.bounds)return[x,y];var bounds=draggable.props.bounds;bounds=\"string\"===typeof bounds?\nbounds:{left:bounds.left,top:bounds.top,right:bounds.right,bottom:bounds.bottom};draggable=findDOMNode(draggable);if(\"string\"===typeof bounds){var ownerDocument=draggable.ownerDocument,ownerWindow=ownerDocument.defaultView;ownerDocument=\"parent\"===bounds?draggable.parentNode:ownerDocument.querySelector(bounds);if(!(ownerDocument instanceof ownerWindow.HTMLElement))throw Error('Bounds selector \"'+bounds+'\" could not find an element.');bounds=ownerWindow.getComputedStyle(draggable);ownerWindow=ownerWindow.getComputedStyle(ownerDocument);\nbounds={left:-draggable.offsetLeft+(0,_shims.int)(ownerWindow.paddingLeft)+(0,_shims.int)(bounds.marginLeft),top:-draggable.offsetTop+(0,_shims.int)(ownerWindow.paddingTop)+(0,_shims.int)(bounds.marginTop),right:(0,_domFns.innerWidth)(ownerDocument)-(0,_domFns.outerWidth)(draggable)-draggable.offsetLeft+(0,_shims.int)(ownerWindow.paddingRight)-(0,_shims.int)(bounds.marginRight),bottom:(0,_domFns.innerHeight)(ownerDocument)-(0,_domFns.outerHeight)(draggable)-draggable.offsetTop+(0,_shims.int)(ownerWindow.paddingBottom)-\n(0,_shims.int)(bounds.marginBottom)}}(0,_shims.isNum)(bounds.right)&&(x=Math.min(x,bounds.right));(0,_shims.isNum)(bounds.bottom)&&(y=Math.min(y,bounds.bottom));(0,_shims.isNum)(bounds.left)&&(x=Math.max(x,bounds.left));(0,_shims.isNum)(bounds.top)&&(y=Math.max(y,bounds.top));return[x,y]};exports.snapToGrid=function(grid,pendingX,pendingY){return[Math.round(pendingX/grid[0])*grid[0],Math.round(pendingY/grid[1])*grid[1]]};exports.canDragX=function(draggable){return\"both\"===draggable.props.axis||\"x\"===\ndraggable.props.axis};exports.canDragY=function(draggable){return\"both\"===draggable.props.axis||\"y\"===draggable.props.axis};exports.getControlPosition=function(e,touchIdentifier,draggableCore){var touchObj=\"number\"===typeof touchIdentifier?(0,_domFns.getTouch)(e,touchIdentifier):null;if(\"number\"===typeof touchIdentifier&&!touchObj)return null;touchIdentifier=findDOMNode(draggableCore);touchIdentifier=draggableCore.props.offsetParent||touchIdentifier.offsetParent||touchIdentifier.ownerDocument.body;\nreturn(0,_domFns.offsetXYFromParent)(touchObj||e,touchIdentifier,draggableCore.props.scale)};exports.createCoreData=function(draggable,x,y){var state=draggable.state,isStart=!(0,_shims.isNum)(state.lastX);draggable=findDOMNode(draggable);return isStart?{node:draggable,deltaX:0,deltaY:0,lastX:x,lastY:y,x:x,y:y}:{node:draggable,deltaX:x-state.lastX,deltaY:y-state.lastY,lastX:state.lastX,lastY:state.lastY,x:x,y:y}};exports.createDraggableData=function(draggable,coreData){var scale=draggable.props.scale;\nreturn{node:coreData.node,x:draggable.state.x+coreData.deltaX/scale,y:draggable.state.y+coreData.deltaY/scale,deltaX:coreData.deltaX/scale,deltaY:coreData.deltaY/scale,lastX:draggable.state.x,lastY:draggable.state.y}};var _shims=require(\"module$node_modules$react_draggable$build$cjs$utils$shims\"),_domFns=require(\"module$node_modules$react_draggable$build$cjs$utils$domFns\")}","~:source","shadow$provide[\"module$node_modules$react_draggable$build$cjs$utils$positionFns\"] = function(global,process,require,module,exports,shadow$shims) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBoundPosition = getBoundPosition;\nexports.snapToGrid = snapToGrid;\nexports.canDragX = canDragX;\nexports.canDragY = canDragY;\nexports.getControlPosition = getControlPosition;\nexports.createCoreData = createCoreData;\nexports.createDraggableData = createDraggableData;\n\nvar _shims = require(\"./shims\");\n\nvar _domFns = require(\"./domFns\");\n\nfunction getBoundPosition(draggable\n/*: Draggable*/\n, x\n/*: number*/\n, y\n/*: number*/\n)\n/*: [number, number]*/\n{\n  // If no bounds, short-circuit and move on\n  if (!draggable.props.bounds) return [x, y]; // Clone new bounds\n\n  var bounds = draggable.props.bounds;\n  bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);\n  var node = findDOMNode(draggable);\n\n  if (typeof bounds === 'string') {\n    var ownerDocument = node.ownerDocument;\n    var ownerWindow = ownerDocument.defaultView;\n    var boundNode;\n\n    if (bounds === 'parent') {\n      boundNode = node.parentNode;\n    } else {\n      boundNode = ownerDocument.querySelector(bounds);\n    }\n\n    if (!(boundNode instanceof ownerWindow.HTMLElement)) {\n      throw new Error('Bounds selector \"' + bounds + '\" could not find an element.');\n    }\n\n    var nodeStyle = ownerWindow.getComputedStyle(node);\n    var boundNodeStyle = ownerWindow.getComputedStyle(boundNode); // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.\n\n    bounds = {\n      left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),\n      top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),\n      right: (0, _domFns.innerWidth)(boundNode) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),\n      bottom: (0, _domFns.innerHeight)(boundNode) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)\n    };\n  } // Keep x and y below right and bottom limits...\n\n\n  if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);\n  if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom); // But above left and top limits.\n\n  if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);\n  if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);\n  return [x, y];\n}\n\nfunction snapToGrid(grid\n/*: [number, number]*/\n, pendingX\n/*: number*/\n, pendingY\n/*: number*/\n)\n/*: [number, number]*/\n{\n  var x = Math.round(pendingX / grid[0]) * grid[0];\n  var y = Math.round(pendingY / grid[1]) * grid[1];\n  return [x, y];\n}\n\nfunction canDragX(draggable\n/*: Draggable*/\n)\n/*: boolean*/\n{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'x';\n}\n\nfunction canDragY(draggable\n/*: Draggable*/\n)\n/*: boolean*/\n{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'y';\n} // Get {x, y} positions from event.\n\n\nfunction getControlPosition(e\n/*: MouseTouchEvent*/\n, touchIdentifier\n/*: ?number*/\n, draggableCore\n/*: DraggableCore*/\n)\n/*: ?ControlPosition*/\n{\n  var touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;\n  if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch\n\n  var node = findDOMNode(draggableCore); // User can provide an offsetParent if desired.\n\n  var offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;\n  return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);\n} // Create an data object exposed by <DraggableCore>'s events\n\n\nfunction createCoreData(draggable\n/*: DraggableCore*/\n, x\n/*: number*/\n, y\n/*: number*/\n)\n/*: DraggableData*/\n{\n  var state = draggable.state;\n  var isStart = !(0, _shims.isNum)(state.lastX);\n  var node = findDOMNode(draggable);\n\n  if (isStart) {\n    // If this is our first move, use the x and y as last coords.\n    return {\n      node: node,\n      deltaX: 0,\n      deltaY: 0,\n      lastX: x,\n      lastY: y,\n      x: x,\n      y: y\n    };\n  } else {\n    // Otherwise calculate proper values.\n    return {\n      node: node,\n      deltaX: x - state.lastX,\n      deltaY: y - state.lastY,\n      lastX: state.lastX,\n      lastY: state.lastY,\n      x: x,\n      y: y\n    };\n  }\n} // Create an data exposed by <Draggable>'s events\n\n\nfunction createDraggableData(draggable\n/*: Draggable*/\n, coreData\n/*: DraggableData*/\n)\n/*: DraggableData*/\n{\n  var scale = draggable.props.scale;\n  return {\n    node: coreData.node,\n    x: draggable.state.x + coreData.deltaX / scale,\n    y: draggable.state.y + coreData.deltaY / scale,\n    deltaX: coreData.deltaX / scale,\n    deltaY: coreData.deltaY / scale,\n    lastX: draggable.state.x,\n    lastY: draggable.state.y\n  };\n} // A lot faster than stringify/parse\n\n\nfunction cloneBounds(bounds\n/*: Bounds*/\n)\n/*: Bounds*/\n{\n  return {\n    left: bounds.left,\n    top: bounds.top,\n    right: bounds.right,\n    bottom: bounds.bottom\n  };\n}\n\nfunction findDOMNode(draggable\n/*: Draggable | DraggableCore*/\n)\n/*: HTMLElement*/\n{\n  var node = draggable.findDOMNode();\n\n  if (!node) {\n    throw new Error('<DraggableCore>: Unmounted during event!');\n  } // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME\n\n\n  return node;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_draggable$build$cjs$utils$domFns","~$shadow.js","~$module$node_modules$react_draggable$build$cjs$utils$shims"]],"~:properties",["^5",["right","canDragX","top","getControlPosition","snapToGrid","lastY","x","__esModule","value","getBoundPosition","createCoreData","createDraggableData","canDragY","y","bottom","deltaX","deltaY","lastX","left","node"]],"~:compiled-at",1601020640397,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_draggable$build$cjs$utils$positionFns.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-draggable/build/cjs/utils/positionFns.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_draggable$build$cjs$utils$positionFns\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.getBoundPosition = getBoundPosition;\\nexports.snapToGrid = snapToGrid;\\nexports.canDragX = canDragX;\\nexports.canDragY = canDragY;\\nexports.getControlPosition = getControlPosition;\\nexports.createCoreData = createCoreData;\\nexports.createDraggableData = createDraggableData;\\n\\nvar _shims = require(\\\"./shims\\\");\\n\\nvar _domFns = require(\\\"./domFns\\\");\\n\\nfunction getBoundPosition(draggable\\n/*: Draggable*/\\n, x\\n/*: number*/\\n, y\\n/*: number*/\\n)\\n/*: [number, number]*/\\n{\\n  // If no bounds, short-circuit and move on\\n  if (!draggable.props.bounds) return [x, y]; // Clone new bounds\\n\\n  var bounds = draggable.props.bounds;\\n  bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);\\n  var node = findDOMNode(draggable);\\n\\n  if (typeof bounds === 'string') {\\n    var ownerDocument = node.ownerDocument;\\n    var ownerWindow = ownerDocument.defaultView;\\n    var boundNode;\\n\\n    if (bounds === 'parent') {\\n      boundNode = node.parentNode;\\n    } else {\\n      boundNode = ownerDocument.querySelector(bounds);\\n    }\\n\\n    if (!(boundNode instanceof ownerWindow.HTMLElement)) {\\n      throw new Error('Bounds selector \\\"' + bounds + '\\\" could not find an element.');\\n    }\\n\\n    var nodeStyle = ownerWindow.getComputedStyle(node);\\n    var boundNodeStyle = ownerWindow.getComputedStyle(boundNode); // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.\\n\\n    bounds = {\\n      left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),\\n      top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),\\n      right: (0, _domFns.innerWidth)(boundNode) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),\\n      bottom: (0, _domFns.innerHeight)(boundNode) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)\\n    };\\n  } // Keep x and y below right and bottom limits...\\n\\n\\n  if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);\\n  if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom); // But above left and top limits.\\n\\n  if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);\\n  if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);\\n  return [x, y];\\n}\\n\\nfunction snapToGrid(grid\\n/*: [number, number]*/\\n, pendingX\\n/*: number*/\\n, pendingY\\n/*: number*/\\n)\\n/*: [number, number]*/\\n{\\n  var x = Math.round(pendingX / grid[0]) * grid[0];\\n  var y = Math.round(pendingY / grid[1]) * grid[1];\\n  return [x, y];\\n}\\n\\nfunction canDragX(draggable\\n/*: Draggable*/\\n)\\n/*: boolean*/\\n{\\n  return draggable.props.axis === 'both' || draggable.props.axis === 'x';\\n}\\n\\nfunction canDragY(draggable\\n/*: Draggable*/\\n)\\n/*: boolean*/\\n{\\n  return draggable.props.axis === 'both' || draggable.props.axis === 'y';\\n} // Get {x, y} positions from event.\\n\\n\\nfunction getControlPosition(e\\n/*: MouseTouchEvent*/\\n, touchIdentifier\\n/*: ?number*/\\n, draggableCore\\n/*: DraggableCore*/\\n)\\n/*: ?ControlPosition*/\\n{\\n  var touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;\\n  if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch\\n\\n  var node = findDOMNode(draggableCore); // User can provide an offsetParent if desired.\\n\\n  var offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;\\n  return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);\\n} // Create an data object exposed by <DraggableCore>'s events\\n\\n\\nfunction createCoreData(draggable\\n/*: DraggableCore*/\\n, x\\n/*: number*/\\n, y\\n/*: number*/\\n)\\n/*: DraggableData*/\\n{\\n  var state = draggable.state;\\n  var isStart = !(0, _shims.isNum)(state.lastX);\\n  var node = findDOMNode(draggable);\\n\\n  if (isStart) {\\n    // If this is our first move, use the x and y as last coords.\\n    return {\\n      node: node,\\n      deltaX: 0,\\n      deltaY: 0,\\n      lastX: x,\\n      lastY: y,\\n      x: x,\\n      y: y\\n    };\\n  } else {\\n    // Otherwise calculate proper values.\\n    return {\\n      node: node,\\n      deltaX: x - state.lastX,\\n      deltaY: y - state.lastY,\\n      lastX: state.lastX,\\n      lastY: state.lastY,\\n      x: x,\\n      y: y\\n    };\\n  }\\n} // Create an data exposed by <Draggable>'s events\\n\\n\\nfunction createDraggableData(draggable\\n/*: Draggable*/\\n, coreData\\n/*: DraggableData*/\\n)\\n/*: DraggableData*/\\n{\\n  var scale = draggable.props.scale;\\n  return {\\n    node: coreData.node,\\n    x: draggable.state.x + coreData.deltaX / scale,\\n    y: draggable.state.y + coreData.deltaY / scale,\\n    deltaX: coreData.deltaX / scale,\\n    deltaY: coreData.deltaY / scale,\\n    lastX: draggable.state.x,\\n    lastY: draggable.state.y\\n  };\\n} // A lot faster than stringify/parse\\n\\n\\nfunction cloneBounds(bounds\\n/*: Bounds*/\\n)\\n/*: Bounds*/\\n{\\n  return {\\n    left: bounds.left,\\n    top: bounds.top,\\n    right: bounds.right,\\n    bottom: bounds.bottom\\n  };\\n}\\n\\nfunction findDOMNode(draggable\\n/*: Draggable | DraggableCore*/\\n)\\n/*: HTMLElement*/\\n{\\n  var node = draggable.findDOMNode();\\n\\n  if (!node) {\\n    throw new Error('<DraggableCore>: Unmounted during event!');\\n  } // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME\\n\\n\\n  return node;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"findDOMNode\",\"draggable\",\"node\",\"Error\",\"Object\",\"defineProperty\",\"value\",\"getBoundPosition\",\"x\",\"y\",\"props\",\"bounds\",\"left\",\"top\",\"right\",\"bottom\",\"ownerDocument\",\"ownerWindow\",\"defaultView\",\"boundNode\",\"parentNode\",\"querySelector\",\"HTMLElement\",\"nodeStyle\",\"getComputedStyle\",\"boundNodeStyle\",\"offsetLeft\",\"_shims\",\"int\",\"paddingLeft\",\"marginLeft\",\"offsetTop\",\"paddingTop\",\"marginTop\",\"_domFns\",\"innerWidth\",\"outerWidth\",\"paddingRight\",\"marginRight\",\"innerHeight\",\"outerHeight\",\"paddingBottom\",\"marginBottom\",\"isNum\",\"Math\",\"min\",\"max\",\"snapToGrid\",\"grid\",\"pendingX\",\"pendingY\",\"round\",\"canDragX\",\"axis\",\"canDragY\",\"getControlPosition\",\"e\",\"touchIdentifier\",\"draggableCore\",\"touchObj\",\"getTouch\",\"offsetParent\",\"body\",\"offsetXYFromParent\",\"scale\",\"createCoreData\",\"state\",\"isStart\",\"lastX\",\"deltaX\",\"deltaY\",\"lastY\",\"createDraggableData\",\"coreData\"]\n}\n"]